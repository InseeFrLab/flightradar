[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Reconstruction de l’interface utilisateur de FlightRadar24",
    "section": "",
    "text": "Flightradar24 est un service de suivi des vols qui fournit des informations en temps réel sur des milliers d’avions dans le monde entier. Le site Internet propose une visualisation interactive des vols en cours à chaque instant, comportant des informations issues de plusieurs sources sur chaque vol. Des données de position sont agrégées avec des données sur les horaires et le statut des vols provenant des compagnies aériennes et des aéroports.\n\n\n\nSite Internet FlightRadar24\n\n\nFlightradar24 vend la plupart de ces données disponibles en temps réel, ainsi que des fichiers d’historiques de vols. Certaines données en temps réel sont toutefois disponibles en accès libre. Il est possible de récupérer ces données de manière programmatique en utilisant par exemple cette librarie Python.\nAvec ce sujet, nous vous proposons de reconstruire une interface utilisateur qui se rapproche de celle du site FlightRadar24 avec Python.\n\n\n\nReconstruction de l’interface utilisateur FlightRadar24\n\n\nAinsi, ce sujet vous permettra :\n\nDe récupérer les données de FlightRadar24 avec interface de programmation Python;\nDéveloppement d’un site interactif avec Dash, un framework Python réputé servant à construire des applications de visualisation de données."
  },
  {
    "objectID": "index.html#récupérer-le-projet-avec-git",
    "href": "index.html#récupérer-le-projet-avec-git",
    "title": "Reconstruction de l’interface utilisateur de FlightRadar24",
    "section": "2.1 Récupérer le projet avec Git ",
    "text": "2.1 Récupérer le projet avec Git \nPour se lancer dans le sujet, commencer par ouvrir un service Vscode-python (par exemple), en modifiant l’onglet Networking de la configuration (cocher la case “Enable a custom service port”). Dans le service, cloner le projet depuis un Terminal avec la commande\ngit clone https://github.com/InseeFrLab/funathon2024_sujet3.git\nLe projet a la structure suivante :\n\nLes fichiers .qmd ainsi que le fichier _quarto.yaml ont servi à la construction de ce site;\n…\nDans le répertoire app se trouve une version d’une application de visualisation."
  },
  {
    "objectID": "index.html#installation-les-librairies-nécessaires",
    "href": "index.html#installation-les-librairies-nécessaires",
    "title": "Reconstruction de l’interface utilisateur de FlightRadar24",
    "section": "2.2 Installation les librairies nécessaires",
    "text": "2.2 Installation les librairies nécessaires\nPour progresser, il vous faudra installer quelques librairies qui sont listées dans le fichier requirements.txt. Pour ce faire, depuis un Terminal, exécutez la commande\npip install -r requirements.txt"
  },
  {
    "objectID": "2-dash.html",
    "href": "2-dash.html",
    "title": "Première version de l’interface utilisateur",
    "section": "",
    "text": "Dans la première partie de ce sujet, nous avons vu comment utiliser une API Python pour récupérer des données de vols en temps réel. Dans cette deuxième partie, nous allons utiliser le framework Python Dash qui permet de construire des applications de visualisation de données rapidement et avec peu de code. Commençons par prendre en main le framework à partir de la documentation.\n\n\n\n\n\n\n Exercice 2 : Prise en main de Dash\n\n\n\n\n\nLe script suivant permet de faire tourner une application Dash minimale à partir des données contenues dans ce fichier .csv. Il est disponible au chemin minimal_app/main.py du dépôt du sujet. Pour exécuter l’application, lancer depuis la racine du projet dans un Terminal la commande\npython minimal_app/main.py\nL’application doit être disponible à une URL indiquée sur l’interface utilisateur du SSP Cloud, une fois cliqué sur le bouton Ouvrir du service Visual Studio Code. Pour rappel il faut ouvrir le service en changeant la configuration (ouverture du port 5000).\n\n\n\nEmplacement du lien pour accéder à l’application Dash\n\n\n\nfrom dash import Dash, html, dcc, callback, Output, Input\nimport plotly.express as px\nimport pandas as pd\n\ndf = pd.read_csv(\n    'https://raw.githubusercontent.com/plotly/datasets/master/gapminder_unfiltered.csv'\n)\n\napp = Dash()\napp.layout = [\n    html.H1(children='Title of Dash App', style={'textAlign': 'center'}),\n    dcc.Dropdown(df.country.unique(), 'Canada', id='dropdown-selection'),\n    dcc.Graph(id='graph-content')\n]\n\n\n@callback(\n    Output('graph-content', 'figure'),\n    Input('dropdown-selection', 'value')\n)\ndef update_graph(value):\n    dff = df[df.country == value]\n    return px.line(dff, x='year', y='pop')\n\nif __name__ == '__main__':\n    app.run(debug=True, port=5000, host='0.0.0.0')\n\nRegarder les différents composants de l’application et identifier les éléments du code correspondants.\n\n\nCliquer pour voir la réponse\n\nL’application est initialisée avec l’instruction app = Dash(). L’attribut layout (mise en page) de l’objet app est ensuite modifié. On ajoute un titre centré, un menu déroulant qui permet de choisir une option parmi une liste de valeurs uniques, puis un emplacement pour un graphique. La fonction update_graph est ensuite définie, qui prend en argument une variable value et renvoie un graphique (line chart) construit à partir des données filtrées à l’aide de la variable value. L’abscisse du graphique correspond à la colonne year du tableau de données, et l’ordonnée à la colonne pop.\nLa fonction est décorée avec @callback, une fonctionnalité majeure de Dash. Une telle fonction est automatiquement appelée chaque fois que la propriété d’un composant d’entrée change, afin de mettre à jour une propriété dans un autre composant (la sortie). En l’occurence le composant de sortie est l’emplacement pour graphique avec l’identifiant 'graph-content' et le composant d’entrée est le menu déroulant avec l’identifiant 'dropdown-selection'. Tout ceci permet d’afficher le graphique correspondant au choix fait par l’utilisateur dans le menu déroulant.\n\n\n\n\nEssayons maintenant d’implémenter une première version de l’application de visualisation des données FlightRadar24.\n\n\n\n\n\n\n Exercice 3 : Première application de visualisation\n\n\n\n\n\nOn souhaite implémenter une première application de visualisation simple, affichant une carte sur laquelle se déplacent en temps réel des points correspondant aux vols Air France en Europe. Un squelette d’application se trouve dans le répertoire intermediate_app, avec des éléments à compléter.\n\nLe répertoire intermediate_app comporte deux fichiers: main.py, qui contient le code de l’application Dash et utils.py qui contient une fonction utilitaire non encore implémentée. Cette fonction utilitaire fetch_flight_data prend en entrée un client FlightRadar, un code ICAO de compagnie aérienne, un type d’aéronef et une zone géographique. Elle renvoie la liste des vols en cours correspondant aux arguments donnés en entrée, où un vol est représenté par un simple dictionnaire avec trois clés 'latitude', 'longitude' et 'id'. Implémenter cette fonction.\n\n\n\nCliquer pour voir la réponse\ndef fetch_flight_data(\n    client: FlightRadar24API,\n    airline_icao: Optional[str] = None,\n    aircraft_type: Optional[str] = None,\n    zone_str: Optional[str] = None\n) -&gt; List[Dict]:\n    \"\"\"\n    Fetch flight data from FlightRadar24 API for\n    a given airline, aircraft type and zone.\n\n    Args:\n        client (FlightRadar24API): FlightRadar24API client.\n        airline_icao (str): ICAO code of the airline.\n        aircraft_type (str): Type of aircraft.\n        zone_str (str): Zone string.\n\n    Returns:\n        List[Dict]: List of flights. A flight should be represented\n            as a dictionary with latitude, longitude and id keys.\n    \"\"\"\n    zone = client.get_zones()[zone_str]\n    bounds = client.get_bounds(zone)\n\n    flights = client.get_flights(\n        aircraft_type=aircraft_type,\n        airline=airline_icao,\n        bounds=bounds\n    )\n    return [\n        {\n            \"latitude\": flight.latitude,\n            \"longitude\": flight.longitude,\n            \"id\": flight.id,\n        } for flight in flights\n    ]\n\n\n\nOn trouve dans le fichier main.py le code de l’application Dash. La mise en page de l’application est simple. Elle contient d’abord un composant dash_leaflet.MapContainer abrévié en dash_leaflet.Map, avec un argument children initialisé avec la liste [dash_leaflet.TileLayer()] qui intègre un fond de carte OpenStreetMap au dash_leaflet.MapContainer.\n\nLe second composant est un dcc.Interval qui va permettre d’initier un callback périodiquement. Ce composant contient un attribut n_intervals (initialisé à 0 ici) qui est incrémenté à interval de temps régulier, toutes les interval millisecondes.\nDe fait, il faut définir la fonction update_graph_live comme un callback. Ecrire un décorateur pour que la fonction soit exécutée à chaque fois que l’attribut n_intervals du composant dcc.Interval est incrémenté, et de sorte à ce que la sortie de la fonction modifie l’attribut children du composant dash_leaflet.MapContainer.\n\n\nCliquer pour voir la réponse\n@app.callback(\n    [Output('map', 'children')],\n    [Input('interval-component', 'n_intervals')],\n)\n\n\n\nOn souhaite maintenant modifier la fonction update_graph_live pour que sa sortie modifie la carte affichée de manière adaptée. Pour le moment, à chaque fois que la fonction est appelée, elle renvoie une liste contenant un fond de carte et un marqueur par vol récupéré grâce à la fonction fetch_flight_data, placé aux latitude et longitude 0.\n\nMettre à jour la liste renvoyée par la fonction update_graph_live pour que les marqueurs soient placés là où se situent les avions des vols, et pour que l’identifiant d’un vol s’affiche lorsqu’on clique sur le marqueur associé.\n\n\nCliquer pour voir la réponse\nchildren = default_map_children + [\n    dl.Marker(\n        position=[flight['latitude'], flight['longitude']],\n        children=[\n            dl.Popup(html.Div([\n                html.H3(flight['id'])\n            ]))\n        ],\n    ) for flight in data\n]\n\n\n\nExécuter l’application en lançant depuis la racine du projet dans un Terminal la commande\n\npython intermediate_app/main.py\nVous devriez observer le résultat suivant :\n\n\n\nPremière application Dash de visualisation des vols\n\n\n\n\n\nDans l’étape suivante, on propose d’améliorer le rendu de l’application en changeant l’icône des marqueurs et en implémentant un calcul du cap de vol des avions en temps réel."
  },
  {
    "objectID": "1-api.html",
    "href": "1-api.html",
    "title": "Interaction avec l’API FlightRadar24",
    "section": "",
    "text": "Cette librairie Python propose une API permettant d’accéder aux données gratuites de FlightRadar24. Une documentation est accessible ici. Pour utiliser l’API, l’idée est d’initialiser un client et de faire appel à plusieurs méthodes pour récupérer différents types de données. Passons à l’exercice.\n\n\n\n\n\n\n Exercice 1 : Utilisation de l’API FlightRadarAPI\n\n\n\n\n\n\nInitialiser un client FlightRadar24API.\n\n\n\nCliquer pour voir la réponse\nfrom FlightRadar24 import FlightRadar24API\nfr_api = FlightRadar24API()\n\n\n\nEn utilisant le client, compter le nombre de compagnies aériennes.\n\n\n\nCliquer pour voir la réponse\nairlines = fr_api.get_airlines()\nprint(f\"Il y a {len(airlines)} compagnies aériennes différentes dont on peut récupérer les vols.\")\n\n\nIl y a 2145 compagnies aériennes différentes dont on peut récupérer les vols.\n\n\n\nCompter le nombre de zones géographiques utilisables et en afficher une selection. Indice : la méthode FlightRadar24API.get_zones retourne un dictionnaire contenant une clé pour chaque zone.\n\n\n\nCliquer pour voir la réponse\nzones = fr_api.get_zones().keys()\nzones = list(zones)\nprint(f\"Il y a {len(zones)} zones différentes, dont les zones '{zones[0]}', '{zones[1]}', '{zones[2]}', etc.\")\n\n\nIl y a 9 zones différentes, dont les zones 'europe', 'northamerica', 'southamerica', etc.\n\n\n\nOn souhaite maintenant récupérer les vols de Boeing 77W en activité en Europe de la compagnie aérienne Air France. Utiliser la méthode FlightRadar24API.get_flights pour donner un compte de ces vols. La chaîne de caractères qui représente Air France est \"AFR\" et celle qui représente le type d’aéronef est \"B77W\". Indice : la méthode à utiliser prend un argument bounds, que la méthode FlightRadar24API.get_bounds permet de récupérer à partir d’une zone géographique.\n\n\n\nCliquer pour voir la réponse\nairline_icao = \"AFR\"\naircraft_type = \"B77W\"\n\nzone = fr_api.get_zones()[\"europe\"]\nbounds = fr_api.get_bounds(zone)\n\nafr_flights = fr_api.get_flights(\n    aircraft_type = aircraft_type,\n    airline = airline_icao,\n    bounds = bounds\n)\nprint(f\"{len(afr_flights)} aéronefs B77W d'Air France sont actuellement en activité en Europe.\")\n\n\n2 aéronefs B77W d'Air France sont actuellement en activité en Europe.\n\n\n\nIl est possible de changer la configuration du client avec les méthodes FlightRadar24API.get_flight_tracker_config et FlightRadar24API.set_flight_tracker_config. Changer la configuration pour récupérer 5 vols à l’aide de la méthode FlightRadar24API.get_flights sans fournir d’argument.\n\n\n\nCliquer pour voir la réponse\nflight_tracker = fr_api.get_flight_tracker_config()\nflight_tracker.limit = 5\nfr_api.set_flight_tracker_config(flight_tracker)\n\nflights = fr_api.get_flights()\nprint(f\"Informations récupérées sur {len(flights)} vols.\")\n\n\nInformations récupérées sur 5 vols.\n\n\n\nPour analyser les détails d’un vol, il faut utiliser les méthodes FlightRadar24API.get_flight_details pour collecter les détails et Flight.set_flight_details pour les attribuer au vol (par défaut seulement quelques informations sont collectées). Explorer les informations disponibles sur un vol (objet de la classe Flight). Par exemple on pourra regarder les attributs suivants :\n\n\nlatitude: Latitude de l’aéronef;\nlongitude: Longitude de l’aéronef;\nid: Identifiant du vol;\nicao_24bit: Identifiant de l’aéronef;\nheading: Cap de vol (en degrés);\naltitude: Altitude (en pieds);\nground_speed: Vitesse au sol (en noeuds);\naircraft_code: Type d’aéronef;\norigin_airport_name: Aéroport d’origine;\ndestination_airport_name: Aéroport de destination;\nairline_iata: Code IATA de compagnie aérienne;\nvertical_speed: Vitesse verticale (en pieds par minute);\nairline_icao: Code ICAO de compagnie aérienne.\n\nEssayez d’identifier les différentes informations associées à un vol.\n\n\nCliquer pour voir la réponse\nflight = flights[2]\nflight_details = fr_api.get_flight_details(flight)\nflight.set_flight_details(flight_details)\nprint(\n  f\"Le vol {flight.id} au départ de l'aéroport {flight.origin_airport_name} \"\n  f\"et à destination de {flight.destination_airport_name} se déplace à une vitesse \"\n  f\"de {flight.ground_speed} noeuds.\"\n)\nprint(\n  f\"L'appareil est un aéronef {flight.aircraft_code} de la compagnie {flight.airline_icao}.\"\n)\n\n\nLe vol 359e6986 au départ de l'aéroport N/A et à destination de N/A se déplace à une vitesse de 1 noeuds.\nL'appareil est un aéronef GLID de la compagnie .\n\n\n\n\n\nDans la partie suivante, nous allons développer une première application de visualisation de vols utilisant cette API Python !"
  }
]